import io
import logging
import os
import re
import subprocess
from datetime import datetime

from reportlab.lib import colors

logger = logging.getLogger(__name__)
from reportlab.lib.pagesizes import A4
from reportlab.lib.styles import ParagraphStyle, getSampleStyleSheet
from reportlab.lib.units import cm
from reportlab.pdfbase import pdfmetrics
from reportlab.pdfbase.ttfonts import TTFont
from reportlab.pdfgen.canvas import Canvas
from reportlab.platypus import (
    SimpleDocTemplate,
    Paragraph,
    Spacer,
    Table,
    TableStyle,
)

from models import SimulationResponse, RiskCategory

RISK_CATEGORY_HEADINGS_EN = {
    RiskCategory.CROWD_SAFETY: "Crowd Safety",
    RiskCategory.TRAFFIC_LOGISTICS: "Traffic & Logistics",
    RiskCategory.ENVIRONMENTAL_HEALTH: "Environmental & Health",
    RiskCategory.OPERATIONAL: "Operational",
    RiskCategory.VISIBILITY: "Visibility & Blind Spots",
    RiskCategory.LEGAL_COMPLIANCE: "Legal & Compliance",
}

RISK_CATEGORY_HEADINGS_JA = {
    RiskCategory.CROWD_SAFETY: "群衆安全",
    RiskCategory.TRAFFIC_LOGISTICS: "交通・物流",
    RiskCategory.ENVIRONMENTAL_HEALTH: "環境・健康",
    RiskCategory.OPERATIONAL: "運営",
    RiskCategory.VISIBILITY: "高さ・死角",
    RiskCategory.LEGAL_COMPLIANCE: "法的留意点",
}

LABELS_JA = {
    "title": "FlowGuard AI",
    "subtitle": "イベントリスク評価レポート",
    "one_page_subtitle": "1枚サマリー",
    "event": "イベント",
    "location": "開催場所",
    "date_time": "開催日時",
    "report_id": "レポートID",
    "generated": "作成日時",
    "executive_summary": "エグゼクティブサマリー",
    "overall_risk_score": "総合リスクスコア",
    "risk_overview": "カテゴリ別リスク概要",
    "category": "カテゴリ",
    "count": "件数",
    "detailed_risks": "リスク詳細",
    "top_risks": "重要リスク（トップ3）",
    "mitigation": "軽減策",
    "recommendations": "推奨事項",
    "immediate_actions": "今すぐやるべき対策",
    "severity": "深刻度",
    "probability": "発生確率",
    "place": "場所",
    "time_series": "時間帯ごとのリスク",
    "time_slot": "時間帯",
    "footer": "本レポートは FlowGuard AI により自動生成されています。計画の参考としてご利用ください。専門的な安全・法務の助言に代わるものではありません。",
    "todo_list": "対策ToDo一覧",
    "status": "状態",
    "done": "完了",
    "pending": "未完了",
    "assignee": "担当",
    "action": "対策内容",
    "due_by": "期限",
    "related_risk": "関連リスク",
    "adopted_todos": "採用済みToDo（次にやるべきから採用）",
    "recommended_routes": "推奨導線",
    "staff_placement": "誘導員配置推奨",
    "map_pins": "地図ピン",
    "pin_name": "名称",
    "pin_memo": "メモ",
    "pin_type": "種別",
    "bottleneck_reason": "理由",
    "bottleneck_measures": "推奨対策",
    "importance": "重要度",
    "urgency": "緊急度",
}

LABELS_EN = {
    "title": "FlowGuard AI",
    "subtitle": "Event Risk Assessment Report",
    "one_page_subtitle": "One-Page Summary",
    "event": "Event",
    "location": "Location",
    "date_time": "Date / Time",
    "report_id": "Report ID",
    "generated": "Generated",
    "executive_summary": "Executive Summary",
    "overall_risk_score": "Overall Risk Score",
    "risk_overview": "Risk Overview by Category",
    "category": "Category",
    "count": "Count",
    "detailed_risks": "Detailed Risk Items",
    "top_risks": "Top 3 Risks",
    "mitigation": "Mitigation",
    "recommendations": "Recommendations",
    "immediate_actions": "Immediate Actions",
    "severity": "Severity",
    "probability": "Probability",
    "place": "Location",
    "time_series": "Risk by Time Slot",
    "time_slot": "Time slot",
    "footer": "This report was generated by FlowGuard AI. It is intended to support planning and does not replace professional safety or legal advice.",
    "todo_list": "Mitigation ToDo List",
    "status": "Status",
    "done": "Done",
    "pending": "Pending",
    "assignee": "Assignee",
    "action": "Action",
    "due_by": "Due by",
    "related_risk": "Related risk",
    "adopted_todos": "Adopted ToDo (from Next Actions)",
    "recommended_routes": "Recommended Routes",
    "staff_placement": "Staff Placement",
    "map_pins": "Map Pins",
    "pin_name": "Name",
    "pin_memo": "Memo",
    "pin_type": "Type",
    "bottleneck_reason": "Reason",
    "bottleneck_measures": "Suggested measures",
    "importance": "Importance",
    "urgency": "Urgency",
}

_JAPANESE_FONT_REGISTERED: bool | None = None
_PDF_FONT_NAME = "Helvetica"

COLOR_PRIMARY = colors.HexColor("#1A237E")
COLOR_HEADER_BG = colors.HexColor("#E8EAF6")
COLOR_ROW_ALT = colors.HexColor("#F5F5F5")
COLOR_BORDER = colors.HexColor("#BDBDBD")
COLOR_TEXT = colors.HexColor("#212121")
COLOR_TEXT_SEC = colors.HexColor("#616161")
COLOR_FOOTER = colors.HexColor("#757575")


def _make_numbered_canvas(pdf_font_name: str):
    class NumberedCanvas(Canvas):
        def __init__(self, *args, **kwargs):
            Canvas.__init__(self, *args, **kwargs)
            self._page_num = 0
            self._font = pdf_font_name

        def showPage(self):
            self._page_num += 1
            self.saveState()
            self.setFont(self._font, 9)
            self.setFillColor(COLOR_FOOTER)
            self.drawCentredString(10.5 * cm, 1.2 * cm, str(self._page_num))
            self.restoreState()
            Canvas.showPage(self)

    return NumberedCanvas


def _get_pdf_font() -> tuple[str, bool]:
    global _JAPANESE_FONT_REGISTERED, _PDF_FONT_NAME
    if _JAPANESE_FONT_REGISTERED is not None:
        return _PDF_FONT_NAME, _JAPANESE_FONT_REGISTERED
    candidates = [
        "/app/fonts/NotoSansCJK.ttc",
        "/app/fonts/ipaex.ttf",
        "/usr/share/fonts/opentype/noto-cjk/NotoSansCJK-Regular.ttc",
        "/usr/share/fonts/truetype/noto-cjk/NotoSansCJK-Regular.ttc",
        "/usr/share/fonts/opentype/noto/NotoSansCJK-Regular.ttc",
        "/usr/share/fonts/truetype/noto/NotoSansCJK-Regular.ttc",
        "/usr/share/fonts/opentype/ipaexfont/ipaexg.ttf",
        "/usr/share/fonts/truetype/fonts-japanese-gothic.ttf",
        "C:/Windows/Fonts/meiryo.ttf",
        "C:/Windows/Fonts/msgothic.ttc",
    ]
    try:
        out = subprocess.run(
            ["fc-list", "--format=%{file}\\n", ":lang=ja"],
            capture_output=True,
            text=True,
            timeout=5,
        )
        if out.returncode == 0 and out.stdout:
            for line in out.stdout.strip().split("\n"):
                path = line.strip().split(":")[0].strip()
                if not path or not os.path.isfile(path):
                    continue
                if path.lower().endswith((".ttf", ".ttc")):
                    low = path.lower()
                    if "noto" in low or "cjk" in low or "japanese" in low or "jp" in low or "ipa" in low:
                        candidates.insert(0, path)
                        break
    except (FileNotFoundError, subprocess.TimeoutExpired):
        pass
    for path in candidates:
        if not os.path.isfile(path):
            continue
        try:
            if path.lower().endswith(".ttc"):
                pdfmetrics.registerFont(TTFont("PdfJapanese", path, subfontIndex=0))
            else:
                pdfmetrics.registerFont(TTFont("PdfJapanese", path))
            _PDF_FONT_NAME = "PdfJapanese"
            _JAPANESE_FONT_REGISTERED = True
            logger.info("PDF Japanese font registered: %s", path)
            return _PDF_FONT_NAME, True
        except Exception as e:
            logger.warning("PDF font registration failed for %s: %s", path, e)
            continue
    logger.warning("No Japanese font available; PDF will show '?' for non-ASCII. Tried: %s", [p for p in candidates if os.path.isfile(p)] or "none found")
    _JAPANESE_FONT_REGISTERED = False
    return _PDF_FONT_NAME, False


def _safe_text(s: str, allow_unicode: bool) -> str:
    if allow_unicode:
        return s
    return re.sub(r"[^\x00-\x7f]", "?", s)


def _truncate(s: str, max_len: int = 80) -> str:
    s = (s or "").strip()
    if len(s) <= max_len:
        return s
    return s[: max_len - 1] + "…"


def _build_one_page_pdf(response: SimulationResponse, buffer: io.BytesIO,
                        pdf_font_name: str, use_unicode: bool,
                        labels: dict, category_headings: dict,
                        delta_summary: dict | None = None) -> None:
    def p(text: str) -> str:
        return _safe_text(text, use_unicode).replace("&", "&amp;").replace("<", "&lt;").replace(">", "&gt;")

    doc = SimpleDocTemplate(
        buffer,
        pagesize=A4,
        rightMargin=1.2 * cm,
        leftMargin=1.2 * cm,
        topMargin=1.0 * cm,
        bottomMargin=0.8 * cm,
    )

    title_style = ParagraphStyle(
        name="OnePageTitle",
        fontName=pdf_font_name,
        fontSize=14,
        spaceAfter=2,
        textColor=COLOR_PRIMARY,
        alignment=0,
    )
    subtitle_style = ParagraphStyle(
        name="OnePageSubtitle",
        fontName=pdf_font_name,
        fontSize=9,
        spaceAfter=8,
        textColor=COLOR_TEXT_SEC,
    )
    meta_style = ParagraphStyle(
        name="OnePageMeta",
        fontName=pdf_font_name,
        fontSize=8,
        spaceAfter=6,
        textColor=COLOR_TEXT,
    )
    section_style = ParagraphStyle(
        name="OnePageSection",
        fontName=pdf_font_name,
        fontSize=9,
        spaceBefore=6,
        spaceAfter=3,
        textColor=COLOR_PRIMARY,
        leftIndent=0,
    )
    body_style = ParagraphStyle(
        name="OnePageBody",
        fontName=pdf_font_name,
        fontSize=8,
        spaceAfter=2,
        textColor=COLOR_TEXT,
    )
    footer_style = ParagraphStyle(
        name="OnePageFooter",
        fontName=pdf_font_name,
        fontSize=7,
        textColor=COLOR_FOOTER,
        spaceBefore=8,
    )

    story = []

    # タイトル
    story.append(Paragraph(labels["title"], title_style))
    story.append(Paragraph(labels["one_page_subtitle"], subtitle_style))

    # イベント・日時・ID（1行に詰める）
    meta_line = (
        f"<b>{labels['event']}:</b> {p(_truncate(response.event_name, 35))}  |  "
        f"<b>{labels['location']}:</b> {p(_truncate(response.event_location or '—', 25))}  |  "
        f"<b>{labels['date_time']}:</b> {p((response.date_time or '—')[:16])}  |  "
        f"ID: {(response.simulation_id or '')[:8]}"
    )
    story.append(Paragraph(meta_line, meta_style))
    story.append(Spacer(1, 0.35 * cm))

    # 総合スコア + カテゴリ件数（1テーブル）
    score_val = f"{response.overall_risk_score:.1f} / 10"
    cat_parts = []
    for cat, count in response.risk_count_by_category.items():
        try:
            label = category_headings.get(RiskCategory(cat), cat)
        except ValueError:
            label = cat
        cat_parts.append(f"{p(label)}:{count}")
    cat_line = "  |  ".join(cat_parts)
    score_table = Table(
        [
            [labels["overall_risk_score"], score_val],
            [labels["risk_overview"], cat_line],
        ],
        colWidths=[3.2 * cm, 14 * cm],
    )
    score_table.setStyle(
        TableStyle([
            ("BACKGROUND", (0, 0), (0, 0), COLOR_PRIMARY),
            ("TEXTCOLOR", (0, 0), (0, 0), colors.white),
            ("FONTNAME", (0, 0), (-1, -1), pdf_font_name),
            ("FONTSIZE", (0, 0), (-1, -1), 8),
            ("BOTTOMPADDING", (0, 0), (-1, -1), 4),
            ("TOPPADDING", (0, 0), (-1, -1), 4),
            ("LEFTPADDING", (0, 0), (-1, -1), 6),
            ("RIGHTPADDING", (0, 0), (-1, -1), 6),
            ("BACKGROUND", (0, 1), (0, 1), COLOR_HEADER_BG),
            ("BOX", (0, 0), (-1, -1), 0.5, COLOR_BORDER),
            ("LINEBELOW", (0, 0), (-1, 0), 0.5, COLOR_BORDER),
        ])
    )
    story.append(score_table)
    story.append(Spacer(1, 0.35 * cm))

    # 対策効果（対策前→対策後）差分
    if delta_summary and isinstance(delta_summary, dict):
        sb = delta_summary.get("riskScoreBefore")
        sa = delta_summary.get("riskScoreAfter")
        db = delta_summary.get("dangerCountBefore")
        da = delta_summary.get("dangerCountAfter")
        cong = delta_summary.get("congestionDeltaMinutes")
        if sb is not None and sa is not None:
            story.append(Paragraph("<b>対策効果（対策前 → 対策後）</b>", section_style))
            delta_rows = [[p("総合リスクスコア"), f"{float(sb):.1f} → {float(sa):.1f}"]]
            if db is not None and da is not None:
                delta_rows.append([p("危険ポイント数"), f"{int(db)}件 → {int(da)}件"])
            if cong is not None and float(cong) != 0:
                delta_rows.append([p("混雑ピーク"), p(f"約{abs(int(float(cong)))}分短縮")])
            tdelta = Table(delta_rows, colWidths=[4 * cm, 5 * cm])
            tdelta.setStyle(
                TableStyle([
                    ("BACKGROUND", (0, 0), (-1, 0), COLOR_HEADER_BG),
                    ("FONTNAME", (0, 0), (-1, -1), pdf_font_name),
                    ("FONTSIZE", (0, 0), (-1, -1), 8),
                    ("BOTTOMPADDING", (0, 0), (-1, -1), 4),
                    ("TOPPADDING", (0, 0), (-1, -1), 4),
                    ("BOX", (0, 0), (-1, -1), 0.5, COLOR_BORDER),
                ])
            )
            story.append(tdelta)
            story.append(Spacer(1, 0.25 * cm))

    # サマリー（1行に要約）
    story.append(Paragraph(f"<b>{labels['executive_summary']}</b>", section_style))
    story.append(Paragraph(p(_truncate(response.summary, 220)), body_style))
    story.append(Spacer(1, 0.25 * cm))

    # 重要リスク トップ3（各1〜2行）
    story.append(Paragraph(f"<b>{labels['top_risks']}</b>", section_style))
    top_risks = sorted(response.risks, key=lambda r: r.severity, reverse=True)[:3]
    for i, r in enumerate(top_risks, 1):
        loc = getattr(r, "location_description", None) or ""
        loc_s = f" — {p(_truncate(loc, 30))}" if loc else ""
        story.append(
            Paragraph(
                f"{i}. <b>{p(_truncate(r.title, 40))}</b> ({labels['severity']}: {r.severity:.1f}){loc_s}",
                body_style,
            )
        )
    story.append(Spacer(1, 0.25 * cm))

    # 今すぐやるべき対策 トップ3
    story.append(Paragraph(f"<b>{labels['immediate_actions']}</b>", section_style))
    for i, rec in enumerate(response.recommendations[:3], 1):
        story.append(Paragraph(f"{i}. {p(_truncate(rec, 95))}", body_style))
    story.append(Spacer(1, 0.2 * cm))

    # 推奨配置・責任分界（1枚サマリー用）
    layout_parts = []
    if response.map_routes:
        rec_routes = [r for r in response.map_routes if r.type == "recommended"]
        if rec_routes:
            layout_parts.append(f"推奨導線 {len(rec_routes)}本")
    if response.bottlenecks:
        layout_parts.append(f"誘導員配置推奨 {len(response.bottlenecks)}箇所")
    if layout_parts:
        story.append(Paragraph(f"<b>推奨配置:</b> {p(', '.join(layout_parts))}", body_style))
    story.append(Paragraph("<b>責任分界:</b> 主催＝全体統括／警備＝誘導・警備／自治体＝許可・監視／施設＝設備・導線。連携窓口を事前に確認すること。", body_style))
    story.append(Spacer(1, 0.2 * cm))

    # 時間帯ごとのリスク（全スロット）
    if getattr(response, "risk_time_series", None):
        slots = response.risk_time_series
        if slots:
            story.append(Paragraph(f"<b>{labels['time_series']}</b>", section_style))
            tdata = [[labels["time_slot"], labels.get("overall_risk_score", "スコア")]]
            for s in slots:
                label = getattr(s, "label", None) or f"{getattr(s, 'start_time', '')[:16]}"
                if len(label) > 20:
                    label = label[:17] + "..."
                score = getattr(s, "risk_score", 0)
                tdata.append([p(label), f"{float(score):.1f}"])
            t = Table(tdata, colWidths=[4 * cm, 2.5 * cm])
            t.setStyle(
                TableStyle([
                    ("BACKGROUND", (0, 0), (-1, 0), COLOR_HEADER_BG),
                    ("FONTNAME", (0, 0), (-1, -1), pdf_font_name),
                    ("FONTSIZE", (0, 0), (-1, -1), 8),
                    ("BOTTOMPADDING", (0, 0), (-1, -1), 4),
                    ("TOPPADDING", (0, 0), (-1, -1), 4),
                    ("LEFTPADDING", (0, 0), (-1, -1), 6),
                    ("RIGHTPADDING", (0, 0), (-1, -1), 6),
                    ("BOX", (0, 0), (-1, -1), 0.5, COLOR_BORDER),
                    ("LINEBELOW", (0, 0), (-1, 0), 0.5, COLOR_BORDER),
                ])
            )
            story.append(t)
            story.append(Spacer(1, 0.2 * cm))

    story.append(Paragraph(f"<i>{labels['footer']}</i>", footer_style))

    doc.build(story)


def _build_full_pdf(
    response: SimulationResponse,
    buffer: io.BytesIO,
    pdf_font_name: str,
    use_unicode: bool,
    labels: dict,
    category_headings: dict,
    delta_summary: dict | None = None,
    site_check_memos: list | None = None,
    todo_checks: dict | None = None,
    adopted_todos: list | None = None,
    pins: list | None = None,
) -> None:
    def p(text: str) -> str:
        return _safe_text(text, use_unicode).replace("&", "&amp;").replace("<", "&lt;").replace(">", "&gt;")

    doc = SimpleDocTemplate(
        buffer,
        pagesize=A4,
        rightMargin=1.8 * cm,
        leftMargin=1.8 * cm,
        topMargin=1.6 * cm,
        bottomMargin=1.4 * cm,
    )

    styles = getSampleStyleSheet()
    title_style = ParagraphStyle(
        name="ReportTitle",
        parent=styles["Heading1"],
        fontName=pdf_font_name,
        fontSize=16,
        spaceAfter=4,
        textColor=COLOR_PRIMARY,
    )
    subtitle_style = ParagraphStyle(
        name="ReportSubtitle",
        fontName=pdf_font_name,
        fontSize=11,
        spaceAfter=12,
        textColor=COLOR_TEXT_SEC,
    )
    heading_style = ParagraphStyle(
        name="SectionHeading",
        parent=styles["Heading2"],
        fontName=pdf_font_name,
        fontSize=11,
        spaceBefore=14,
        spaceAfter=6,
        textColor=COLOR_PRIMARY,
        borderPadding=(0, 0, 0, 0),
    )
    body_style = ParagraphStyle(
        name="ReportBody",
        parent=styles["Normal"],
        fontName=pdf_font_name,
        fontSize=9,
        spaceAfter=5,
        textColor=COLOR_TEXT,
    )
    heading3_style = ParagraphStyle(
        name="ReportHeading3",
        parent=styles["Heading3"],
        fontName=pdf_font_name,
        fontSize=10,
        spaceBefore=8,
        spaceAfter=4,
        textColor=COLOR_TEXT,
    )
    table_cell_style = ParagraphStyle(
        name="TableCell",
        parent=styles["Normal"],
        fontName=pdf_font_name,
        fontSize=8,
        spaceBefore=0,
        spaceAfter=0,
        textColor=COLOR_TEXT,
        leading=10,
    )
    footer_style = ParagraphStyle(
        name="Footer",
        fontName=pdf_font_name,
        fontSize=8,
        textColor=COLOR_FOOTER,
        spaceBefore=12,
    )

    story = []

    # ヘッダー
    story.append(Paragraph(labels["title"], title_style))
    story.append(Paragraph(labels["subtitle"], subtitle_style))
    story.append(Spacer(1, 0.4 * cm))

    # イベント情報（読みやすいブロック）
    story.append(
        Paragraph(
            f"<b>{labels['event']}:</b> {p(response.event_name)}<br/>"
            f"<b>{labels['location']}:</b> {p(response.event_location or '—')}<br/>"
            f"<b>{labels['date_time']}:</b> {p(response.date_time or '—')}<br/>"
            f"<b>{labels['report_id']}:</b> {response.simulation_id or '—'}  ·  "
            f"<b>{labels['generated']}:</b> {datetime.utcnow().strftime('%Y-%m-%d %H:%M UTC')}",
            body_style,
        )
    )
    story.append(Spacer(1, 0.6 * cm))

    # エグゼクティブサマリー
    story.append(Paragraph(labels["executive_summary"], heading_style))
    story.append(Paragraph(p(response.summary), body_style))
    story.append(Spacer(1, 0.4 * cm))

    # 総合リスクスコア（見やすいテーブル）
    score_table = Table(
        [[labels["overall_risk_score"], f"{response.overall_risk_score:.1f} / 10"]],
        colWidths=[5 * cm, 4 * cm],
    )
    score_table.setStyle(
        TableStyle([
            ("BACKGROUND", (0, 0), (0, 0), COLOR_PRIMARY),
            ("TEXTCOLOR", (0, 0), (0, 0), colors.white),
            ("BACKGROUND", (1, 0), (1, 0), COLOR_ROW_ALT),
            ("FONTNAME", (0, 0), (-1, -1), pdf_font_name),
            ("FONTSIZE", (0, 0), (-1, -1), 10),
            ("ALIGN", (0, 0), (0, 0), "LEFT"),
            ("ALIGN", (1, 0), (1, 0), "CENTER"),
            ("BOTTOMPADDING", (0, 0), (-1, -1), 10),
            ("TOPPADDING", (0, 0), (-1, -1), 10),
            ("LEFTPADDING", (0, 0), (-1, -1), 8),
            ("RIGHTPADDING", (0, 0), (-1, -1), 8),
            ("BOX", (0, 0), (-1, -1), 0.5, COLOR_BORDER),
        ])
    )
    story.append(score_table)
    story.append(Spacer(1, 0.6 * cm))

    # 対策効果（対策前→対策後）差分
    if delta_summary and isinstance(delta_summary, dict):
        sb = delta_summary.get("riskScoreBefore")
        sa = delta_summary.get("riskScoreAfter")
        db = delta_summary.get("dangerCountBefore")
        da = delta_summary.get("dangerCountAfter")
        cong = delta_summary.get("congestionDeltaMinutes")
        if sb is not None and sa is not None:
            story.append(Paragraph("対策効果（対策前 → 対策後）", heading_style))
            delta_rows = [[p("総合リスクスコア"), f"{float(sb):.1f} → {float(sa):.1f}"]]
            if db is not None and da is not None:
                delta_rows.append([p("危険ポイント数"), f"{int(db)}件 → {int(da)}件"])
            if cong is not None and float(cong) != 0:
                delta_rows.append([p("混雑ピーク"), p(f"約{abs(int(float(cong)))}分短縮")])
            tdelta = Table(delta_rows, colWidths=[5 * cm, 5 * cm])
            tdelta.setStyle(
                TableStyle([
                    ("BACKGROUND", (0, 0), (-1, 0), COLOR_HEADER_BG),
                    ("FONTNAME", (0, 0), (-1, -1), pdf_font_name),
                    ("FONTSIZE", (0, 0), (-1, -1), 9),
                    ("BOTTOMPADDING", (0, 0), (-1, -1), 8),
                    ("TOPPADDING", (0, 0), (-1, -1), 8),
                    ("BOX", (0, 0), (-1, -1), 0.5, COLOR_BORDER),
                ])
            )
            story.append(tdelta)
            story.append(Spacer(1, 0.4 * cm))

    # 対策ToDo一覧（全タスク・完了/未完了）
    tasks = getattr(response, "mitigation_tasks", None) or []
    if tasks:
        story.append(Paragraph(labels["todo_list"], heading_style))
        checked_set = set()
        if isinstance(todo_checks, dict):
            for tid, v in todo_checks.items():
                if v:
                    checked_set.add(str(tid))
        todo_data = [[labels["status"], labels["assignee"], labels["action"], labels["due_by"]]]
        for t in tasks:
            tid = getattr(t, "id", "") or ""
            status = labels["done"] if tid in checked_set else labels["pending"]
            who = p((getattr(t, "who", "") or "")[:12])
            action_text = (getattr(t, "action", "") or "").strip()
            action_flowable = Paragraph(p(action_text), table_cell_style) if action_text else Paragraph("—", table_cell_style)
            due = (getattr(t, "due_by", "") or "—")[:10]
            todo_data.append([status, who, action_flowable, due])
        if len(todo_data) > 1:
            t_todo = Table(todo_data, colWidths=[1.8 * cm, 2.2 * cm, 10.5 * cm, 2.2 * cm])
            todo_style = [
                ("BACKGROUND", (0, 0), (-1, 0), COLOR_HEADER_BG),
                ("FONTNAME", (0, 0), (-1, -1), pdf_font_name),
                ("FONTSIZE", (0, 0), (-1, -1), 8),
                ("BOTTOMPADDING", (0, 0), (-1, -1), 5),
                ("TOPPADDING", (0, 0), (-1, -1), 5),
                ("LEFTPADDING", (0, 0), (-1, -1), 6),
                ("RIGHTPADDING", (0, 0), (-1, -1), 6),
                ("BOX", (0, 0), (-1, -1), 0.5, COLOR_BORDER),
                ("LINEBELOW", (0, 0), (-1, 0), 1, COLOR_BORDER),
            ]
            for i in range(1, len(todo_data)):
                if i % 2 == 0:
                    todo_style.append(("BACKGROUND", (0, i), (-1, i), COLOR_ROW_ALT))
            t_todo.setStyle(TableStyle(todo_style))
            story.append(t_todo)
        story.append(Spacer(1, 0.5 * cm))

    # 採用済みToDo（次にやるべきから採用した項目）
    if adopted_todos and isinstance(adopted_todos, list) and len(adopted_todos) > 0:
        story.append(Paragraph(labels["adopted_todos"], heading_style))
        for i, item in enumerate(adopted_todos, 1):
            if not isinstance(item, dict):
                continue
            action = item.get("action") or item.get("title") or "—"
            who = (item.get("who") or "").strip() or "—"
            risk_id = item.get("risk_id") or ""
            story.append(
                Paragraph(
                    f"{i}. [{p(who)}] {p(str(action)[:70])}"
                    + (f"  <i>({labels['related_risk']}: {p(str(risk_id)[:20])})</i>" if risk_id else ""),
                    body_style,
                )
            )
        story.append(Spacer(1, 0.5 * cm))

    # カテゴリ別概要（ヘッダー＋交互背景）
    story.append(Paragraph(labels["risk_overview"], heading_style))
    cat_data = [[labels["category"], labels["count"]]]
    for cat, count in response.risk_count_by_category.items():
        try:
            label = category_headings.get(RiskCategory(cat), cat)
        except ValueError:
            label = cat
        cat_data.append([p(label), str(count)])
    cat_table = Table(cat_data, colWidths=[8 * cm, 3 * cm])
    cat_style = [
        ("BACKGROUND", (0, 0), (-1, 0), COLOR_HEADER_BG),
        ("FONTNAME", (0, 0), (-1, -1), pdf_font_name),
        ("FONTSIZE", (0, 0), (-1, -1), 9),
        ("BOTTOMPADDING", (0, 0), (-1, -1), 8),
        ("TOPPADDING", (0, 0), (-1, -1), 8),
        ("LEFTPADDING", (0, 0), (-1, -1), 8),
        ("RIGHTPADDING", (0, 0), (-1, -1), 8),
        ("BOX", (0, 0), (-1, -1), 0.5, COLOR_BORDER),
        ("LINEBELOW", (0, 0), (-1, 0), 1, COLOR_BORDER),
    ]
    for i in range(1, len(cat_data)):
        if i % 2 == 0:
            cat_style.append(("BACKGROUND", (0, i), (-1, i), COLOR_ROW_ALT))
    cat_table.setStyle(TableStyle(cat_style))
    story.append(cat_table)
    story.append(Spacer(1, 0.6 * cm))

    # 時間帯ごとのリスク（全スロット）
    if getattr(response, "risk_time_series", None) and response.risk_time_series:
        slots = response.risk_time_series
        story.append(Paragraph(labels["time_series"], heading_style))
        tdata = [[labels["time_slot"], labels.get("overall_risk_score", "スコア")]]
        for s in slots:
            label = getattr(s, "label", None) or (getattr(s, "start_time", "")[:16] if getattr(s, "start_time", None) else "—")
            if len(label) > 24:
                label = label[:21] + "..."
            score = getattr(s, "risk_score", 0)
            tdata.append([p(label), f"{float(score):.1f}"])
        t = Table(tdata, colWidths=[6 * cm, 3 * cm])
        t.setStyle(
            TableStyle([
                ("BACKGROUND", (0, 0), (-1, 0), COLOR_HEADER_BG),
                ("FONTNAME", (0, 0), (-1, -1), pdf_font_name),
                ("FONTSIZE", (0, 0), (-1, -1), 9),
                ("BOTTOMPADDING", (0, 0), (-1, -1), 8),
                ("TOPPADDING", (0, 0), (-1, -1), 8),
                ("LEFTPADDING", (0, 0), (-1, -1), 8),
                ("RIGHTPADDING", (0, 0), (-1, -1), 8),
                ("BOX", (0, 0), (-1, -1), 0.5, COLOR_BORDER),
                ("LINEBELOW", (0, 0), (-1, 0), 1, COLOR_BORDER),
            ])
        )
        story.append(t)
        story.append(Spacer(1, 0.6 * cm))

    # 推奨導線・誘導員配置
    routes = getattr(response, "map_routes", None) or []
    rec_routes = [r for r in routes if getattr(r, "type", "") == "recommended"]
    bottlenecks = getattr(response, "bottlenecks", None) or []
    if rec_routes or bottlenecks:
        story.append(Paragraph(labels["recommended_routes"], heading_style))
        if rec_routes:
            route_labels = ", ".join(p(getattr(r, "label", "") or getattr(r, "id", "")[:8]) for r in rec_routes[:10])
            story.append(
                Paragraph(
                    f"{p(labels['recommended_routes'])}: {len(rec_routes)} — {route_labels}",
                    body_style,
                )
            )
        if bottlenecks:
            story.append(Paragraph(labels["staff_placement"], heading3_style))
            for b in bottlenecks[:15]:
                loc = p((getattr(b, "location_description", "") or "")[:50])
                reason = p((getattr(b, "reason", "") or "")[:40])
                story.append(Paragraph(f"・ {loc} — {labels['bottleneck_reason']}: {reason}", body_style))
                measures = getattr(b, "suggested_measures", None) or []
                if measures:
                    story.append(Paragraph(f"  {labels['bottleneck_measures']}: " + p("; ".join(measures)[:80]), body_style))
        story.append(Spacer(1, 0.5 * cm))

    # 現場確認メモ（テンプレ＋メモを差し込み）
    if site_check_memos and isinstance(site_check_memos, list) and len(site_check_memos) > 0:
        story.append(Paragraph("現場確認メモ", heading_style))
        for item in site_check_memos:
            if not isinstance(item, dict):
                continue
            label = item.get("label") or item.get("id") or "—"
            category = item.get("category") or ""
            memo = (item.get("memo") or "").strip()
            linked = item.get("linkedTaskId")
            line = f"<b>{p(str(label))}</b>"
            if category:
                line += f" （{p(str(category))}）"
            story.append(Paragraph(line, body_style))
            if memo:
                story.append(Paragraph(p(memo), body_style))
            if linked:
                story.append(Paragraph(f"<i>関連ToDo: {p(str(linked)[:20])}</i>", body_style))
            story.append(Spacer(1, 0.2 * cm))
        story.append(Spacer(1, 0.4 * cm))

    # 地図ピン一覧
    if pins and isinstance(pins, list) and len(pins) > 0:
        story.append(Paragraph(labels["map_pins"], heading_style))
        pin_data = [[labels["pin_name"], labels["pin_type"], labels["pin_memo"]]]
        for pin in pins:
            if not isinstance(pin, dict):
                continue
            name = p((pin.get("name") or pin.get("id") or "—")[:30])
            typ = p((pin.get("type") or "other")[:12])
            memo = p((pin.get("memo") or "—")[:50])
            pin_data.append([name, typ, memo])
        if len(pin_data) > 1:
            t_pins = Table(pin_data, colWidths=[4 * cm, 2.5 * cm, 9 * cm])
            t_pins.setStyle(
                TableStyle([
                    ("BACKGROUND", (0, 0), (-1, 0), COLOR_HEADER_BG),
                    ("FONTNAME", (0, 0), (-1, -1), pdf_font_name),
                    ("FONTSIZE", (0, 0), (-1, -1), 9),
                    ("BOTTOMPADDING", (0, 0), (-1, -1), 6),
                    ("TOPPADDING", (0, 0), (-1, -1), 6),
                    ("BOX", (0, 0), (-1, -1), 0.5, COLOR_BORDER),
                    ("LINEBELOW", (0, 0), (-1, 0), 1, COLOR_BORDER),
                ])
            )
            story.append(t_pins)
        story.append(Spacer(1, 0.5 * cm))

    # リスク詳細（セクション見出しを明確に）
    story.append(Paragraph(labels["detailed_risks"], heading_style))
    for cat in RiskCategory:
        risks_in_cat = [r for r in response.risks if r.category == cat]
        if not risks_in_cat:
            continue
        cat_label = category_headings.get(cat, getattr(cat, "value", str(cat)))
        story.append(Paragraph(cat_label, heading3_style))
        for r in risks_in_cat:
            extra = []
            imp = getattr(r, "importance", None)
            urg = getattr(r, "urgency", None)
            if imp is not None:
                extra.append(f"{labels['importance']}: {float(imp):.1f}")
            if urg is not None:
                extra.append(f"{labels['urgency']}: {float(urg):.1f}")
            line = f"<b>{p(r.title)}</b>  ·  {labels['severity']}: {r.severity:.1f}  ·  {labels['probability']}: {r.probability * 100:.0f}%"
            if extra:
                line += "  ·  " + "  ·  ".join(extra)
            story.append(Paragraph(line, body_style))
            loc_desc = getattr(r, "location_description", None) or ""
            if loc_desc:
                story.append(Paragraph(f"<b>{labels['place']}:</b> {p(loc_desc)}", body_style))
            story.append(Paragraph(p(r.description), body_style))
            if r.mitigation_actions:
                story.append(
                    Paragraph(
                        f"<b>{labels['mitigation']}:</b> " + p("; ".join(r.mitigation_actions)),
                        body_style,
                    )
                )
            story.append(Spacer(1, 0.15 * cm))
        story.append(Spacer(1, 0.25 * cm))

    # 推奨事項
    story.append(Paragraph(labels["recommendations"], heading_style))
    for i, rec in enumerate(response.recommendations, 1):
        story.append(Paragraph(f"{i}. {p(rec)}", body_style))
    story.append(Spacer(1, 0.4 * cm))

    story.append(Paragraph(f"<i>{labels['footer']}</i>", footer_style))

    doc.build(story, canvasmaker=_make_numbered_canvas(pdf_font_name))


def _filter_tasks_by_role(tasks: list, variant: str) -> list:
    v = (variant or "").strip().lower()
    if not tasks:
        return []
    role_who = {
        "role_organizer": ["主催", "主催者", "運営", "その他"],
        "role_security": ["警備", "誘導", "保安", "救護"],
        "role_local_gov": ["自治体", "許可", "監視", "報告"],
        "role_venue_manager": ["施設", "設備", "導線"],
        "runbook": [],
    }
    keywords = role_who.get(v, [])
    if not keywords:
        return tasks
    out = []
    for t in tasks:
        who = (t.who or "").strip()
        if any(k in who for k in keywords):
            out.append(t)
    return out if out else tasks


def _build_role_todo_pdf(
    response: SimulationResponse,
    buffer: io.BytesIO,
    pdf_font_name: str,
    use_unicode: bool,
    labels: dict,
    variant: str,
) -> None:
    def p(text: str) -> str:
        return _safe_text(text, use_unicode).replace("&", "&amp;").replace("<", "&lt;").replace(">", "&gt;")

    role_titles = {
        "role_organizer": "主催者用 ToDo",
        "role_security": "警備用 ToDo",
        "role_local_gov": "自治体用 ToDo",
        "role_venue_manager": "施設管理用 ToDo",
        "runbook": "運用手順書 ToDo",
    }
    title = role_titles.get((variant or "").strip().lower(), "役割別 ToDo")

    doc = SimpleDocTemplate(buffer, pagesize=A4, rightMargin=1.5 * cm, leftMargin=1.5 * cm, topMargin=1.2 * cm, bottomMargin=1.2 * cm)
    body_style = ParagraphStyle(
        name="Body", fontName=pdf_font_name, fontSize=9, spaceAfter=4, textColor=COLOR_TEXT,
    )
    heading_style = ParagraphStyle(
        name="Heading", fontName=pdf_font_name, fontSize=12, spaceAfter=8, textColor=COLOR_PRIMARY,
    )
    story = []
    story.append(Paragraph(labels["title"], heading_style))
    story.append(Paragraph(title, ParagraphStyle(name="Sub", fontName=pdf_font_name, fontSize=10, spaceAfter=6, textColor=COLOR_TEXT_SEC)))
    story.append(Paragraph(f"{labels['event']}: {p(response.event_name)}  |  {labels['date_time']}: {p((response.date_time or '')[:16])}", body_style))
    story.append(Spacer(1, 0.5 * cm))

    tasks = _filter_tasks_by_role(response.mitigation_tasks, variant)
    for i, t in enumerate(tasks, 1):
        line = f"□ {i}. [{p(t.who or '担当')}] {p((t.action or '')[:80])}"
        if t.due_by:
            line += f" （期限: {p(t.due_by[:10])}）"
        story.append(Paragraph(line, body_style))
    story.append(Spacer(1, 0.3 * cm))
    story.append(Paragraph(f"<i>{labels['footer']}</i>", ParagraphStyle(name="Foot", fontName=pdf_font_name, fontSize=7, textColor=COLOR_FOOTER)))
    doc.build(story)


def build_pdf(
    response: SimulationResponse,
    variant: str = "full",
    delta_summary: dict | None = None,
    site_check_memos: list | None = None,
    todo_checks: dict | None = None,
    adopted_todos: list | None = None,
    pins: list | None = None,
) -> bytes:
    pdf_font_name, use_unicode = _get_pdf_font()
    is_ja = getattr(response, "locale", "ja") == "ja"
    labels = LABELS_JA if is_ja else LABELS_EN
    category_headings = RISK_CATEGORY_HEADINGS_JA if is_ja else RISK_CATEGORY_HEADINGS_EN

    buffer = io.BytesIO()
    v = (variant or "").strip().lower()
    if v == "one_page":
        _build_one_page_pdf(response, buffer, pdf_font_name, use_unicode, labels, category_headings, delta_summary)
    elif v in ("role_organizer", "role_security", "role_local_gov", "role_venue_manager", "runbook"):
        _build_role_todo_pdf(response, buffer, pdf_font_name, use_unicode, labels, v)
    else:
        _build_full_pdf(
            response,
            buffer,
            pdf_font_name,
            use_unicode,
            labels,
            category_headings,
            delta_summary=delta_summary,
            site_check_memos=site_check_memos,
            todo_checks=todo_checks,
            adopted_todos=adopted_todos,
            pins=pins,
        )

    return buffer.getvalue()
